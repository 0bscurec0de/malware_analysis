import pefile
import hashlib
from Crypto.Cipher import AES

__AUTHOR__ = 'd4rkd0pp3lg4ng3r'


class TrickBot(object):
    __magic_bot = b'\x74\xD0\x13\x64\x6E\xDE'
    __magic_exe = b'\x4D\x5A\x90\x00'
    __modules = ['bot_32', 'bot_64', 'loader_64']
    __BS = 16

    @staticmethod
    def _load_file(file_path: str):
        with open(file_path, 'rb') as file:
            data = file.read()
        return data

    @staticmethod
    def _save_file(file_name: str, binary: bytes):
        with open(file_name, 'wb') as file:
            file.write(binary)

    @staticmethod
    def _load_resources(pe_file: pefile.PE):
        rt_index = [entry.id for entry in pe_file.DIRECTORY_ENTRY_RESOURCE.entries] \
            .index(pefile.RESOURCE_TYPE['RT_RCDATA'])
        return pe_file.DIRECTORY_ENTRY_RESOURCE.entries[rt_index].directory.entries

    @staticmethod
    def _decode_payload(data: bytes):
        decoded_data = bytearray()
        key = 0x3039

        for item in data:
            decoded_data.append(item ^ (key & 0xFF))
            key = key * 0x0AE529 + 0x24D69
        return decoded_data

    @staticmethod
    def _hash_rounds(data_buf):
        while len(data_buf) <= 0x1000:
            buf_hash = hashlib.sha256(data_buf).digest()
            data_buf += buf_hash
        return buf_hash

    def __init__(self, path_file: str):
        self._binary = self._load_file(path_file)

        if self.__magic_exe in self._binary:
            self._pe_file = pefile.PE(data=self._binary)
            self._res = dict()
            self._get_bots()
            self._bot_pe_file = pefile.PE(data=self._res['bot_32'])
            self._get_config()

    def _decode_module(self):
        decoded = self._aes_decrypt(self._binary)
        return decoded[decoded.find(self.__magic_exe):]

    def _aes_decrypt(self, data):
        key = self._hash_rounds(data[:0x20])[:0x20]
        iv = self._hash_rounds(data[0x10:0x30])[:0x10]
        aes = AES.new(key, AES.MODE_CBC, iv)
        return aes.decrypt(self._pad(data[0x30:]))

    def _pad(self, s):
        return bytes(s + bytes((self.__BS - len(s) % self.__BS) * chr(self.__BS - len(s) % self.__BS), 'utf8'))

    def _get_config(self):
        rt_config = self._load_resources(self._bot_pe_file)[0]
        data_rva = rt_config.directory.entries[0].data.struct.OffsetToData
        size = rt_config.directory.entries[0].data.struct.Size

        raw_data = self._aes_decrypt(self._bot_pe_file.get_data(data_rva, size)[4:])
        raw_data = raw_data[raw_data.find(b'<'):]
        self._res['config'] = raw_data[:raw_data.find(b'>', raw_data.rfind(b'</'))+1]

    def _get_bots(self):
        rt_entries = self._load_resources(self._pe_file)

        for j in range(0, len(rt_entries)):
            data_rva = rt_entries[j].directory.entries[0].data.struct.OffsetToData
            size = rt_entries[j].directory.entries[0].data.struct.Size
            data = self._pe_file.get_data(data_rva, size)

            if self.__magic_bot in data:
                self._res[self.__modules[j]] = self._decode_payload(data)
        return

    def get_data(self):
        if self.__magic_exe in self._binary:
            for item in self._res:
                self._save_file(item, self._res[item])
        elif self.__magic_bot in self._binary:
            self._save_file('trick_bot', self._decode_payload(self._binary))
        else:
            self._save_file('trick_bot', self._decode_module())
